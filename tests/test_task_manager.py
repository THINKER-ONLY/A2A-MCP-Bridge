import pytest
from unittest.mock import AsyncMock, patch, MagicMock
import uuid
import httpx
from typing import Any

# Assuming your project structure allows these imports
# If Adapter/src is not in PYTHONPATH, you might need to adjust
from src.translator.task_manager import MCPGatewayAgentTaskManager
from src.vendor.A2A.types import (
    SendTaskRequest,
    Message,
    DataPart,
    TextPart,
    TaskStatus,
    TaskState,
    Artifact,
    JSONRPCError as A2AJSONRPCError,
    TaskSendParams
)
from src.vendor.MCP import types as mcp_types

@pytest.fixture
def task_manager():
    """Fixture to create an instance of MCPGatewayAgentTaskManager."""
    return MCPGatewayAgentTaskManager()

@pytest.fixture
def mock_send_mcp_request():
    """Fixture to mock the send_mcp_request function as used by the task_manager."""
    with patch("src.translator.task_manager.send_mcp_request", new_callable=AsyncMock) as mock_func:
        yield mock_func

@pytest.mark.asyncio
async def test_on_send_task_successful_tools_call(task_manager: MCPGatewayAgentTaskManager, mock_send_mcp_request: AsyncMock):
    """
    Tests a successful 'tools/call' scenario.
    The A2A task provides valid MCP tool call parameters.
    The mocked MCP service returns a successful JSON-RPC response.
    The TaskManager should return a completed A2A task with the MCP result.
    """
    a2a_request_params_id = "test-a2a-req-params-id-1"
    task_id = "test-task-id-1"
    session_id = "test-session-id-1"
    mcp_target_url = "http://fake-mcp-service.com"
    mcp_method = "tools/call"
    mcp_tool_name = "test_tool"
    mcp_tool_args = {"param1": "value1", "param2": 123}
    
    # This will be the ID generated by _build_mcp_request_body if not provided in input
    # We can also test providing it in input DataPart
    expected_mcp_request_id = str(uuid.uuid4()) 

    # 1. Construct A2A SendTaskRequest
    input_data_payload = {
        "mcp_target_url": mcp_target_url,
        "mcp_method": mcp_method,
        "mcp_params": {"name": mcp_tool_name, "arguments": mcp_tool_args},
        "mcp_request_id": expected_mcp_request_id # Optional: test with pre-set ID
    }
    a2a_message = Message(role="user", parts=[DataPart(data=input_data_payload)])
    
    # 修改 SendTaskRequest 的构造
    task_send_params_obj = TaskSendParams(
        id=task_id,
        sessionId=session_id,
        message=a2a_message
    )
    send_task_request_obj = SendTaskRequest(id=a2a_request_params_id, params=task_send_params_obj)

    # 2. Mock the response from send_mcp_request
    mcp_result_content_text = "Tool call was successful!"
    # According to MCP types, CallToolResult has 'content' which is a list of TextContent, ImageContent, or EmbeddedResource
    mcp_call_tool_result = mcp_types.CallToolResult(
        content=[mcp_types.TextContent(type="text", text=mcp_result_content_text)]
    )
    # The 'result' field of JSONRPCResponse should be a dict (model_dump of CallToolResult)
    mocked_mcp_service_response = mcp_types.JSONRPCResponse(
        jsonrpc="2.0",
        id=expected_mcp_request_id, 
        result=mcp_call_tool_result.model_dump(exclude_none=True)
    )
    mock_send_mcp_request.return_value = mocked_mcp_service_response.model_dump(exclude_none=True)

    # 3. Call on_send_task
    a2a_response = await task_manager.on_send_task(send_task_request_obj)

    # 4. Assert A2A response
    assert a2a_response.id == a2a_request_params_id
    assert a2a_response.error is None
    assert a2a_response.result is not None
    
    returned_task = a2a_response.result
    assert returned_task.id == task_id
    assert returned_task.status.state == TaskState.COMPLETED
    assert "MCP request processed successfully" in returned_task.status.message.parts[0].text # type: ignore

    assert len(returned_task.artifacts) == 1
    output_artifact = returned_task.artifacts[0]
    assert isinstance(output_artifact, Artifact)
    assert output_artifact.name == "MCP Service Response"
    
    assert len(output_artifact.parts) == 1
    output_data_part = output_artifact.parts[0]
    assert isinstance(output_data_part, DataPart)
    
    # Directly check the keys within the result payload
    assert "content" in output_data_part.data # Check for 'content' key directly
    assert output_data_part.data["content"][0]["text"] == mcp_result_content_text
    assert "error" not in output_data_part.data # Ensure no error part

    # Check metadata in the artifact's DataPart
    assert output_data_part.metadata is not None
    assert output_data_part.metadata["mcp_request_id_echo"] == expected_mcp_request_id


    # 5. Assert that send_mcp_request was called correctly
    mock_send_mcp_request.assert_called_once()
    call_args = mock_send_mcp_request.call_args
    
    # First positional argument is the target_url
    assert call_args[0][0] == f"{mcp_target_url}/messages/" # Default path
    
    # Second positional argument is the mcp_json_rpc_request_dict
    sent_mcp_request_body = call_args[0][1]
    assert sent_mcp_request_body["jsonrpc"] == "2.0"
    assert sent_mcp_request_body["id"] == expected_mcp_request_id
    assert sent_mcp_request_body["method"] == mcp_method
    assert sent_mcp_request_body["params"]["name"] == mcp_tool_name
    assert sent_mcp_request_body["params"]["arguments"] == mcp_tool_args

@pytest.mark.asyncio
async def test_on_send_task_successful_resources_read(task_manager: MCPGatewayAgentTaskManager, mock_send_mcp_request: AsyncMock):
    """
    测试成功的 'resources/read' 场景。
    A2A 任务提供有效的 MCP 资源读取参数。
    模拟的 MCP 服务返回成功的 JSON-RPC 响应。
    TaskManager 应返回一个已完成的 A2A 任务，其中包含 MCP 结果。
    """
    a2a_request_params_id = "test-a2a-req-params-id-res-read"
    task_id = "test-task-id-res-read"
    session_id = "test-session-id-res-read"
    mcp_target_url = "http://fake-mcp-resource-service.com"
    mcp_method = "resources/read"
    resource_uri_to_read = "fake://resource/data.txt"
    mcp_request_path = "/custom/mcp/" # 测试非默认路径

    expected_mcp_request_id = str(uuid.uuid4())

    # 1. 构造 A2A SendTaskRequest
    input_data_payload = {
        "mcp_target_url": mcp_target_url,
        "mcp_method": mcp_method,
        "mcp_params": {"uri": resource_uri_to_read},
        "mcp_request_path": mcp_request_path,
        "mcp_request_id": expected_mcp_request_id
    }
    a2a_message = Message(role="user", parts=[DataPart(data=input_data_payload)])
    
    # 修改 SendTaskRequest 的构造
    task_send_params_obj = TaskSendParams(
        id=task_id,
        sessionId=session_id,
        message=a2a_message
    )
    send_task_request_obj = SendTaskRequest(id=a2a_request_params_id, params=task_send_params_obj)

    # 2. 模拟来自 send_mcp_request 的响应
    resource_content_text = "This is the content of the fake resource."
    mcp_read_resource_result = mcp_types.ReadResourceResult(
        contents=[
            mcp_types.TextResourceContents(
                type="text", 
                uri=resource_uri_to_read, # MCP SDK 要求 uri 字段
                text=resource_content_text,
                mimeType="text/plain" # MCP SDK 要求 mimeType 字段
            )
        ]
    )
    mocked_mcp_service_response = mcp_types.JSONRPCResponse(
        jsonrpc="2.0",
        id=expected_mcp_request_id,
        result=mcp_read_resource_result.model_dump(exclude_none=True)
    )
    mock_send_mcp_request.return_value = mocked_mcp_service_response.model_dump(exclude_none=True)

    # 3. 调用 on_send_task
    a2a_response = await task_manager.on_send_task(send_task_request_obj)

    # 4. 断言 A2A 响应
    assert a2a_response.id == a2a_request_params_id
    assert a2a_response.error is None
    assert a2a_response.result is not None

    returned_task = a2a_response.result
    assert returned_task.id == task_id
    assert returned_task.status.state == TaskState.COMPLETED
    assert "MCP request processed successfully" in returned_task.status.message.parts[0].text # type: ignore

    assert len(returned_task.artifacts) == 1
    output_artifact = returned_task.artifacts[0]
    assert output_artifact.name == "MCP Service Response"

    assert len(output_artifact.parts) == 1
    output_data_part = output_artifact.parts[0]
    assert isinstance(output_data_part, DataPart)

    # Directly check the keys within the result payload
    assert "contents" in output_data_part.data # Check for 'contents' key directly
    mcp_result_from_a2a = output_data_part.data # Data itself is the result
    assert len(mcp_result_from_a2a["contents"]) == 1
    assert mcp_result_from_a2a["contents"][0]["text"] == resource_content_text
    assert str(mcp_result_from_a2a["contents"][0]["uri"]) == resource_uri_to_read # <-- 转换为字符串比较
    assert "error" not in output_data_part.data # Ensure no error part

    assert output_data_part.metadata is not None
    assert output_data_part.metadata["mcp_request_id_echo"] == expected_mcp_request_id

    # 5. 断言 send_mcp_request 被正确调用
    mock_send_mcp_request.assert_called_once()
    call_args = mock_send_mcp_request.call_args
    assert call_args[0][0] == f"{mcp_target_url.rstrip('/')}/{mcp_request_path.lstrip('/')}"
    
    sent_mcp_request_body = call_args[0][1]
    assert sent_mcp_request_body["jsonrpc"] == "2.0"
    assert sent_mcp_request_body["id"] == expected_mcp_request_id
    assert sent_mcp_request_body["method"] == mcp_method
    assert sent_mcp_request_body["params"]["uri"] == resource_uri_to_read

@pytest.mark.asyncio
async def test_on_send_task_mcp_service_returns_json_rpc_error(task_manager: MCPGatewayAgentTaskManager, mock_send_mcp_request: AsyncMock):
    """
    测试当 MCP 服务返回一个结构化的 JSON-RPC 错误时 TaskManager 的行为。
    HTTP 调用本身是成功的，但 MCP 服务在其响应中指出了一个错误。
    """
    a2a_request_params_id = "test-a2a-req-params-id-mcp-error"
    task_id = "test-task-id-mcp-error"
    session_id = "test-session-id-mcp-error"
    mcp_target_url = "http://fake-mcp-service-causing-error.com"
    mcp_method_to_call = "tools/call"
    mcp_params = {"name": "failing_tool", "arguments": {"bad_param": "trigger_error"}}
    
    expected_mcp_request_id = str(uuid.uuid4())

    # 1. 构造 A2A SendTaskRequest
    input_data_payload = {
        "mcp_target_url": mcp_target_url,
        "mcp_method": mcp_method_to_call,
        "mcp_params": mcp_params,
        "mcp_request_id": expected_mcp_request_id
    }
    a2a_message = Message(role="user", parts=[DataPart(data=input_data_payload)])
    
    # 修改 SendTaskRequest 的构造
    task_send_params_obj = TaskSendParams(
        id=task_id,
        sessionId=session_id,
        message=a2a_message
    )
    send_task_request_obj = SendTaskRequest(id=a2a_request_params_id, params=task_send_params_obj)

    # 2. 模拟 MCP 服务返回的 JSON-RPC 错误响应
    mcp_error_code = -32001
    mcp_error_message = "MCP Tool execution failed due to invalid parameter."
    mcp_error_data = {"detail": "Parameter 'bad_param' was not expected."}
    
    # 这是 MCP 服务实际返回的 JSON 结构 (send_mcp_request 的返回值)
    mocked_mcp_service_error_response_dict = {
        "jsonrpc": "2.0",
        "id": expected_mcp_request_id, # MCP 响应的 ID 应与请求的 ID 匹配
        "error": {
            "code": mcp_error_code,
            "message": mcp_error_message,
            "data": mcp_error_data
        }
    }
    mock_send_mcp_request.return_value = mocked_mcp_service_error_response_dict

    # 3. 调用 on_send_task
    a2a_response = await task_manager.on_send_task(send_task_request_obj)

    # 4. 断言 A2A 响应的 error 部分
    assert a2a_response.id == a2a_request_params_id
    assert a2a_response.error is not None
    assert isinstance(a2a_response.error, A2AJSONRPCError)
    assert a2a_response.error.code == mcp_error_code
    assert a2a_response.error.message == mcp_error_message
    assert a2a_response.error.data == mcp_error_data

    # 5. 断言 A2A 响应的 result 部分 (Task 对象)
    assert a2a_response.result is not None
    returned_task = a2a_response.result
    assert returned_task.id == task_id
    assert returned_task.status.state == TaskState.FAILED
    
    # 检查 TaskStatus.message
    assert returned_task.status.message is not None
    assert len(returned_task.status.message.parts) == 1
    status_text_part = returned_task.status.message.parts[0]
    assert isinstance(status_text_part, TextPart)
    # _format_a2a_result_on_error 会将 A2AJSONRPCError 的 message 放入 TextPart
    assert mcp_error_message in status_text_part.text 

    # 检查 Artifacts
    assert len(returned_task.artifacts) == 1
    output_artifact = returned_task.artifacts[0]
    assert isinstance(output_artifact, Artifact)
    assert "MCP Call Communication Error" in output_artifact.name # 名称来自 _format_a2a_result_on_error
    assert mcp_error_message in output_artifact.description

    assert len(output_artifact.parts) == 1
    output_data_part = output_artifact.parts[0]
    assert isinstance(output_data_part, DataPart)

    # 检查输出 DataPart.data 的内容 (_format_a2a_result_on_error 的结果)
    assert "source_error" in output_data_part.data
    source_error_dict = output_data_part.data["source_error"]
    assert source_error_dict["code"] == mcp_error_code
    assert source_error_dict["message"] == mcp_error_message
    assert source_error_dict["data"] == mcp_error_data
    assert output_data_part.data["mcp_request_id_echo"] == expected_mcp_request_id

    # 6. 断言 send_mcp_request 被正确调用
    mock_send_mcp_request.assert_called_once()
    call_args = mock_send_mcp_request.call_args
    assert call_args[0][0] == f"{mcp_target_url}/messages/" # 默认路径
    sent_mcp_request_body = call_args[0][1]
    assert sent_mcp_request_body["id"] == expected_mcp_request_id
    assert sent_mcp_request_body["method"] == mcp_method_to_call
    assert sent_mcp_request_body["params"] == mcp_params

@pytest.mark.asyncio
async def test_on_send_task_mcp_http_status_error(task_manager: MCPGatewayAgentTaskManager, mock_send_mcp_request: AsyncMock):
    """
    测试当与 MCP 服务的 HTTP 调用返回状态错误 (例如 404, 500) 时 TaskManager 的行为。
    这模拟了网络层之上的 HTTP 错误，响应体可能不是 JSON-RPC 错误。
    """
    a2a_request_params_id = "test-a2a-req-params-id-http-error"
    task_id = "test-task-id-http-error"
    session_id = "test-session-id-http-error"
    mcp_target_url = "http://non-existent-mcp-service.com"
    mcp_method_to_call = "tools/call"
    mcp_params = {"name": "any_tool", "arguments": {}}
    
    expected_mcp_request_id = str(uuid.uuid4())

    # 1. 构造 A2A SendTaskRequest
    input_data_payload = {
        "mcp_target_url": mcp_target_url,
        "mcp_method": mcp_method_to_call,
        "mcp_params": mcp_params,
        "mcp_request_id": expected_mcp_request_id
    }
    a2a_message = Message(role="user", parts=[DataPart(data=input_data_payload)])
    
    # 修改 SendTaskRequest 的构造
    task_send_params_obj = TaskSendParams(
        id=task_id,
        sessionId=session_id,
        message=a2a_message
    )
    send_task_request_obj = SendTaskRequest(id=a2a_request_params_id, params=task_send_params_obj)

    # 2. 模拟 send_mcp_request 抛出 HTTPStatusError
    http_status_code = 404
    error_message_from_http = f"{http_status_code} Client Error: Not Found for url {mcp_target_url}/messages/"
    
    # 构建一个模拟的 httpx.Request 对象，因为 HTTPStatusError 需要它
    mock_httpx_request = httpx.Request(method="POST", url=f"{mcp_target_url}/messages/")
    # 构建一个模拟的 httpx.Response 对象
    mock_httpx_response = httpx.Response(status_code=http_status_code, request=mock_httpx_request, content=b"Resource not found")

    # mcp_client.py 中的 send_mcp_request 会捕获 httpx.HTTPStatusError 并可能重新构造它，
    # 但最终 _execute_mcp_call 会捕获一个 httpx.HTTPError 类型的异常。
    # 我们直接让 mock 抛出它，模拟 mcp_client 处理后的结果或原始错误。
    mock_send_mcp_request.side_effect = httpx.HTTPStatusError(
        message=error_message_from_http, 
        request=mock_httpx_request, 
        response=mock_httpx_response
    )

    # 3. 调用 on_send_task
    a2a_response = await task_manager.on_send_task(send_task_request_obj)

    # 4. 断言 A2A 响应的 error 部分
    assert a2a_response.id == a2a_request_params_id
    assert a2a_response.error is not None
    assert isinstance(a2a_response.error, A2AJSONRPCError)
    # _execute_mcp_call 会使用 HTTP 状态码作为错误码
    assert a2a_response.error.code == http_status_code 
    # 消息可能包含原始 httpx 错误信息
    assert error_message_from_http in a2a_response.error.message 
    assert isinstance(a2a_response.error.data, dict)
    assert f"(URL: {mcp_target_url}/messages/)" in a2a_response.error.data.get("details", "")

    # 5. 断言 A2A 响应的 result 部分 (Task 对象)
    assert a2a_response.result is not None
    returned_task = a2a_response.result
    assert returned_task.id == task_id
    assert returned_task.status.state == TaskState.FAILED
    
    assert returned_task.status.message is not None
    status_text_part = returned_task.status.message.parts[0]
    assert isinstance(status_text_part, TextPart)
    assert error_message_from_http in status_text_part.text

    assert len(returned_task.artifacts) == 1
    output_artifact = returned_task.artifacts[0]
    assert isinstance(output_artifact, Artifact)
    assert "MCP Call Communication Error" in output_artifact.name
    assert error_message_from_http in output_artifact.description

    assert len(output_artifact.parts) == 1
    output_data_part = output_artifact.parts[0]
    assert isinstance(output_data_part, DataPart)
    
    assert "source_error" in output_data_part.data
    source_error_dict = output_data_part.data["source_error"]
    assert source_error_dict["code"] == http_status_code
    assert error_message_from_http in source_error_dict["message"]
    assert output_data_part.data["mcp_request_id_echo"] == expected_mcp_request_id

    # 6. 断言 send_mcp_request 被正确调用
    mock_send_mcp_request.assert_called_once()

@pytest.mark.asyncio
async def test_on_send_task_mcp_network_error(task_manager: MCPGatewayAgentTaskManager, mock_send_mcp_request: AsyncMock):
    """
    测试当与 MCP 服务的 HTTP 调用发生网络级别错误 (例如连接失败) 时 TaskManager 的行为。
    """
    a2a_request_params_id = "test-a2a-req-params-id-network-error"
    task_id = "test-task-id-network-error"
    session_id = "test-session-id-network-error"
    mcp_target_url = "http://unreachable-mcp-service.com"
    mcp_method_to_call = "tools/call"
    mcp_params = {"name": "any_tool", "arguments": {}}
    
    expected_mcp_request_id = str(uuid.uuid4())

    # 1. 构造 A2A SendTaskRequest
    input_data_payload = {
        "mcp_target_url": mcp_target_url,
        "mcp_method": mcp_method_to_call,
        "mcp_params": mcp_params,
        "mcp_request_id": expected_mcp_request_id
    }
    a2a_message = Message(role="user", parts=[DataPart(data=input_data_payload)])
    
    # 修改 SendTaskRequest 的构造
    task_send_params_obj = TaskSendParams(
        id=task_id,
        sessionId=session_id,
        message=a2a_message
    )
    send_task_request_obj = SendTaskRequest(id=a2a_request_params_id, params=task_send_params_obj)

    # 2. 模拟 send_mcp_request 抛出网络连接错误 (httpx.ConnectError)
    network_error_message = "Connection refused"
    mock_httpx_request = httpx.Request(method="POST", url=f"{mcp_target_url}/messages/")
    
    # ConnectError 是 RequestError 的子类
    # mcp_client.py 会捕获 RequestError, _execute_mcp_call 也会捕获它。
    mock_send_mcp_request.side_effect = httpx.ConnectError(network_error_message, request=mock_httpx_request)

    # 3. 调用 on_send_task
    a2a_response = await task_manager.on_send_task(send_task_request_obj)

    # 4. 断言 A2A 响应的 error 部分
    assert a2a_response.id == a2a_request_params_id
    assert a2a_response.error is not None
    assert isinstance(a2a_response.error, A2AJSONRPCError)
    
    # _execute_mcp_call 应该为网络错误设置一个通用的错误代码
    # 例如，如果它捕获了 httpx.RequestError 并转换为 A2AJSONRPCError
    # 它可能会使用类似 mcp_types.INTERNAL_ERROR 的代码，或者一个特定的代码表示网络问题
    # 根据 task_manager.py 中的 _execute_mcp_call, HTTPError 的 code 是 status_code or mcp_types.INTERNAL_ERROR
    # 对于 ConnectError, response 是 None, status_code 也是 None，所以会是 mcp_types.INTERNAL_ERROR
    assert a2a_response.error.code == mcp_types.INTERNAL_ERROR 
    assert network_error_message in a2a_response.error.message
    assert isinstance(a2a_response.error.data, dict)
    assert f"(URL: {mcp_target_url}/messages/)" in a2a_response.error.data.get("details", "")

    # 5. 断言 A2A 响应的 result 部分 (Task 对象)
    assert a2a_response.result is not None
    returned_task = a2a_response.result
    assert returned_task.id == task_id
    assert returned_task.status.state == TaskState.FAILED
    
    assert returned_task.status.message is not None
    status_text_part = returned_task.status.message.parts[0]
    assert isinstance(status_text_part, TextPart)
    assert network_error_message in status_text_part.text

    assert len(returned_task.artifacts) == 1
    output_artifact = returned_task.artifacts[0]
    assert isinstance(output_artifact, Artifact)
    assert "MCP Call Communication Error" in output_artifact.name
    assert network_error_message in output_artifact.description

    assert len(output_artifact.parts) == 1
    output_data_part = output_artifact.parts[0]
    assert isinstance(output_data_part, DataPart)
    
    assert "source_error" in output_data_part.data
    source_error_dict = output_data_part.data["source_error"]
    assert source_error_dict["code"] == mcp_types.INTERNAL_ERROR
    assert network_error_message in source_error_dict["message"]
    assert output_data_part.data["mcp_request_id_echo"] == expected_mcp_request_id

    # 6. 断言 send_mcp_request 被正确调用
    mock_send_mcp_request.assert_called_once()

@pytest.mark.asyncio
@pytest.mark.parametrize(
    "missing_field", ["mcp_target_url", "mcp_method", "mcp_params"]
)
async def test_on_send_task_invalid_a2a_input_missing_required_field(
    task_manager: MCPGatewayAgentTaskManager, 
    mock_send_mcp_request: AsyncMock, 
    missing_field: str
):
    """
    测试当 A2A 输入的 DataPart 缺少必需字段 (mcp_target_url, mcp_method, mcp_params) 时 TaskManager 的行为。
    应返回一个包含参数错误信息的 A2A JSONRPCError。
    """
    a2a_request_params_id = f"test-a2a-req-params-id-missing-{missing_field}"
    task_id = f"test-task-id-missing-{missing_field}"
    session_id = f"test-session-id-missing-{missing_field}"
    
    # 完整的基础 payload
    input_data_payload_base = {
        "mcp_target_url": "http://some-service.com",
        "mcp_method": "tools/call",
        "mcp_params": {"name": "a_tool", "arguments": {}},
        "mcp_request_path": "/v1/",
        "mcp_request_id": "mcp-req-missing-field-test"
    }
    
    # 从 payload 中移除当前参数化的 missing_field
    invalid_input_data_payload = input_data_payload_base.copy()
    del invalid_input_data_payload[missing_field]
    
    a2a_message = Message(role="user", parts=[DataPart(data=invalid_input_data_payload)])
    
    # 修改 SendTaskRequest 的构造
    task_send_params_obj = TaskSendParams(
        id=task_id,
        sessionId=session_id,
        message=a2a_message
    )
    send_task_request_obj = SendTaskRequest(id=a2a_request_params_id, params=task_send_params_obj)

    # 调用 on_send_task
    a2a_response = await task_manager.on_send_task(send_task_request_obj)

    # 断言 A2A 响应的 error 部分
    assert a2a_response.id == a2a_request_params_id
    assert a2a_response.error is not None
    assert isinstance(a2a_response.error, A2AJSONRPCError)
    assert a2a_response.error.code == -32602 # Invalid Params
    assert f"缺少必需字段: {missing_field}" in a2a_response.error.message
    assert isinstance(a2a_response.error.data, dict)
    assert a2a_response.error.data["detail"] == f"Missing required field: {missing_field}"

    # 断言 A2A 响应的 result 部分 (Task 对象)
    assert a2a_response.result is not None # TaskManager 即使在解析输入错误时也返回 Task 对象
    returned_task = a2a_response.result
    assert returned_task.id == task_id
    assert returned_task.status.state == TaskState.FAILED
    
    assert returned_task.status.message is not None
    status_data_part = returned_task.status.message.parts[0]
    assert isinstance(status_data_part, DataPart) # _parse_a2a_input 失败时，状态消息包含 DataPart
    assert status_data_part.data["error_summary"] == "无效的 A2A 任务输入。"
    assert status_data_part.data["detail"]["message"] == f"缺少必需字段: {missing_field}"
    
    assert not returned_task.artifacts # 验证错误，不应有 artifacts

    # 确保 send_mcp_request 在输入解析失败时未被调用
    mock_send_mcp_request.assert_not_called()

@pytest.mark.asyncio
@pytest.mark.parametrize(
    "field_to_corrupt, corrupted_value, expected_message_segment",
    [
        ("mcp_target_url", 123, "mcp_target_url 必须是字符串"),
        ("mcp_method", True, "mcp_method 必须是字符串"),
        ("mcp_params", "not_a_dict", "mcp_params 必须是字典"),
        ("mcp_request_path", 12345, "mcp_request_path 必须是字符串"), # 虽然可选，但如果提供，类型也应正确
        ("mcp_request_id", [], "mcp_request_id 必须是字符串或整数") # 虽然可选，但如果提供，类型也应正确
    ]
)
async def test_on_send_task_invalid_a2a_input_wrong_type(
    task_manager: MCPGatewayAgentTaskManager, 
    mock_send_mcp_request: AsyncMock, 
    field_to_corrupt: str, 
    corrupted_value: Any,
    expected_message_segment: str
):
    """
    测试当 A2A 输入的 DataPart 中字段类型错误时 TaskManager 的行为。
    应返回一个包含参数错误信息的 A2A JSONRPCError。
    """
    a2a_request_params_id = f"test-a2a-req-params-id-wrong-type-{field_to_corrupt}"
    task_id = f"test-task-id-wrong-type-{field_to_corrupt}"
    session_id = f"test-session-id-wrong-type-{field_to_corrupt}"
    
    valid_payload_base = {
        "mcp_target_url": "http://some-service.com",
        "mcp_method": "tools/call",
        "mcp_params": {"name": "a_tool", "arguments": {}},
        "mcp_request_path": "/v1/",
        "mcp_request_id": "mcp-req-id-wrong-type-test"
    }
    
    # 替换指定字段为错误类型的值
    invalid_input_data_payload = valid_payload_base.copy()
    invalid_input_data_payload[field_to_corrupt] = corrupted_value
    
    a2a_message = Message(role="user", parts=[DataPart(data=invalid_input_data_payload)])
    
    # 修改 SendTaskRequest 的构造
    task_send_params_obj = TaskSendParams(
        id=task_id,
        sessionId=session_id,
        message=a2a_message
    )
    send_task_request_obj = SendTaskRequest(id=a2a_request_params_id, params=task_send_params_obj)

    # 调用 on_send_task
    a2a_response = await task_manager.on_send_task(send_task_request_obj)

    # 断言 A2A 响应的 error 部分
    assert a2a_response.id == a2a_request_params_id
    assert a2a_response.error is not None
    assert isinstance(a2a_response.error, A2AJSONRPCError)
    assert a2a_response.error.code == -32602 # Invalid Params
    assert expected_message_segment in a2a_response.error.message

    # 断言 A2A 响应的 result 部分 (Task 对象)
    assert a2a_response.result is not None
    returned_task = a2a_response.result
    assert returned_task.id == task_id
    assert returned_task.status.state == TaskState.FAILED
    
    assert returned_task.status.message is not None
    status_data_part = returned_task.status.message.parts[0]
    assert isinstance(status_data_part, DataPart)
    assert status_data_part.data["error_summary"] == "无效的 A2A 任务输入。"
    if "detail" in status_data_part.data and isinstance(status_data_part.data["detail"], dict):
        assert expected_message_segment in status_data_part.data["detail"].get("message", "")

    assert not returned_task.artifacts
    mock_send_mcp_request.assert_not_called()

# Placeholder for more tests
# async def test_on_send_task_successful_resources_read(...):
# async def test_on_send_task_mcp_returns_json_rpc_error(...):
# async def test_on_send_task_mcp_network_error(...):
# async def test_on_send_task_invalid_a2a_input_missing_field(...):
# async def test_on_send_task_invalid_a2a_input_wrong_type(...):

# 可以添加更多测试用例，例如：
# - 测试调用 MCP 资源读取 (resources/read)
# - 测试 MCP 服务返回错误的场景
# - 测试网络错误或目标 MCP 服务不可达的场景
# - 测试输入 A2A 请求无效的场景 (例如缺少 mcp_target_url) 